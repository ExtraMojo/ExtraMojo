{"/ExtraMojo/extramojo/":{"data":{"extramojo#\u003ccode\u003eextramojo\u003c/code\u003e":"Mojo package ü°≠\nextramojo","packages#Packages":" bstr: String-like operations on List[UInt8] and Span[UInt8]. cli: The cli module contains functionality for creating and using command line applications. collections io: IO. math stats: Basic stats. "},"title":"extramojo"},"/ExtraMojo/extramojo/bstr/":{"data":{"bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo package ü°≠\nbstrString-like operations on List[UInt8] and Span[UInt8].","modules#Modules":" bstr memchr: Fast memchr implementations. ","references#References":" Rust bstr "},"title":"bstr"},"/ExtraMojo/extramojo/bstr/bstr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = simd_width_of[DType.uint8]() CAPITAL_A = SIMD[DType.uint8, SIMD_U8_WIDTH](ord(\"A\")) CAPITAL_Z = SIMD[DType.uint8, SIMD_U8_WIDTH](ord(\"Z\")) LOWER_A = SIMD[DType.uint8, SIMD_U8_WIDTH](ord(\"a\")) LOWER_Z = SIMD[DType.uint8, SIMD_U8_WIDTH](ord(\"z\")) ASCII_CASE_MASK = 32 ZERO = 0 ","bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo module ü°≠\nbstr","functions#Functions":" find_chr_all_occurrences is_ascii_uppercase is_ascii_lowercase to_ascii_lowercase to_ascii_uppercase find ","structs#Structs":" SplitIterator: Get an iterator the yields the splits from the input to_split string. "},"title":"bstr"},"/ExtraMojo/extramojo/bstr/bstr/SplitIterator/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" inner (Span[UInt8, origin]) split_on (UInt8) current (Int) len (Int) next_split (Optional[_StartEnd]) ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, to_split: Span[UInt8, origin], split_on: UInt8) Details Args:\nto_split (Span) split_on (UInt8) self (Self) Returns:\nSelf\n__iter__ fn __iter__(var self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Details Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Details Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e Span[UInt8, origin] Details Args:\nself (Self) Returns:\nSpan\npeek fn peek(self) -\u003e Optional[Span[UInt8, origin]] Peek ahead at the next split result. Args:\nself (Self) Returns:\nOptional","parameters#Parameters":" is_mutable (Bool) origin (Origin) ","splititerator#\u003ccode\u003eSplitIterator\u003c/code\u003e":"Mojo struct ü°≠\nSplitIterator @memory_only struct SplitIterator[is_mutable: Bool, //, origin: Origin[is_mutable]] Get an iterator the yields the splits from the input `to_split` string. TODO: these test run fine in the test module, but not in doctests. ``` from testing import assert_equal from extramojo.bstr.bstr import SplitIterator var input = \"ABCD\tEFGH\tIJKL MNOP\".as_bytes() var expected = List( ‚ÄúABCD‚Äù.as_bytes(), ‚ÄúEFGH‚Äù.as_bytes(), ‚ÄúIJKL MNOP‚Äù.as_bytes() ) var output = ListSpan[UInt8, StaticConstantOrigin] for value in SplitIterator(input, ord(\"\t‚Äú)): output.append(value) for i in range(len(expected)): assert_equal(StringSlice(unsafe_from_utf8=output[i]), StringSlice(unsafe_from_utf8=expected[i])) ```\n``` from collections.string.string_slice import StringSlice from testing import assert_equal from extramojo.bstr.bstr import SplitIterator var input = \"ABCD\tEFGH\tIJKL MNOP‚Äù.as_bytes() var expected = List( ‚ÄúABCD‚Äù.as_bytes(), ‚ÄúEFGH‚Äù.as_bytes(), ‚ÄúIJKL MNOP‚Äù.as_bytes() ) var iter = SplitIterator(input, ord(\"\t‚Äú)) var first = iter.next() var peek = iter.peek() var second = iter.next() assert_equal(StringSlice(unsafe_from_utf8=peek.value()), StringSlice(unsafe_from_utf8=second)) assert_equal(StringSlice(unsafe_from_utf8=first), StringSlice(unsafe_from_utf8=expected[0])) assert_equal(StringSlice(unsafe_from_utf8=second), StringSlice(unsafe_from_utf8=expected[1])) ```"},"title":"SplitIterator"},"/ExtraMojo/extramojo/bstr/bstr/find/":{"data":{"find#\u003ccode\u003efind\u003c/code\u003e":"Mojo function ü°≠\nfind ‚ûï¬† ‚ûñ fn find(haystack: Span[UInt8, origin], needle: Span[UInt8, origin]) -\u003e Optional[Int] Look for the substring needle in the haystack. This is not a terribly smart find implementation. It will use memchr to find occurrences of the first byte in the needle, it then checks the subsequent bytes to see if they match the rest of the needle.\nfrom testing import assert_equal from extramojo.bstr.bstr import find var haystack = \"ABCDEFGhijklmnop\".as_bytes() var expected = 4 var answer = find(haystack, \"EFG\".as_bytes()).value() assert_equal(answer, expected) Args:\nhaystack (Span): The bytes to be searched for the needle. needle (Span): The bytes to search for in the haystack. Returns:\nOptional: Index of the start of the first occurrence of needle."},"title":"find"},"/ExtraMojo/extramojo/bstr/bstr/find_chr_all_occurrences/":{"data":{"find_chr_all_occurrences#\u003ccode\u003efind_chr_all_occurrences\u003c/code\u003e":"Mojo function ü°≠\nfind_chr_all_occurrences ‚ûï¬† ‚ûñ fn find_chr_all_occurrences(haystack: Span[UInt8, origin], chr: UInt8) -\u003e List[Int] Find all the occurrences of chr in the input buffer. from testing import assert_equal from extramojo.bstr.bstr import find_chr_all_occurrences var haystack = \"ATCGACCATCGAGATCATGTTTCAT\" var expected = List(2, 5, 6, 9, 15, 22) assert_equal(find_chr_all_occurrences(haystack.as_bytes(), ord(\"C\")), expected) Args:\nhaystack (Span) chr (UInt8) Returns:\nList"},"title":"find_chr_all_occurrences"},"/ExtraMojo/extramojo/bstr/bstr/is_ascii_lowercase/":{"data":{"is_ascii_lowercase#\u003ccode\u003eis_ascii_lowercase\u003c/code\u003e":"Mojo function ü°≠\nis_ascii_lowercase ‚ûï¬† ‚ûñ fn is_ascii_lowercase(value: UInt8) -\u003e Bool Check if a byte is ASCII lowercase. from testing import assert_true, assert_false from extramojo.bstr.bstr import is_ascii_lowercase for ascii_letter in range(ord(\"A\"), ord(\"Z\")+1): assert_false(is_ascii_lowercase(ascii_letter)) for ascii_letter in range(ord(\"a\"), ord(\"z\")+1): assert_true(is_ascii_lowercase(ascii_letter)) assert_false(is_ascii_lowercase(0)) Args:\nvalue (UInt8) Returns:\nBool"},"title":"is_ascii_lowercase"},"/ExtraMojo/extramojo/bstr/bstr/is_ascii_uppercase/":{"data":{"is_ascii_uppercase#\u003ccode\u003eis_ascii_uppercase\u003c/code\u003e":"Mojo function ü°≠\nis_ascii_uppercase ‚ûï¬† ‚ûñ fn is_ascii_uppercase(value: UInt8) -\u003e Bool Check if a byte is ASCII uppercase. from testing import assert_true, assert_false from extramojo.bstr.bstr import is_ascii_uppercase for ascii_letter in range(ord(\"A\"), ord(\"Z\")+1): assert_true(is_ascii_uppercase(ascii_letter)) for ascii_letter in range(ord(\"a\"), ord(\"z\")+1): assert_false(is_ascii_uppercase(ascii_letter)) assert_false(is_ascii_uppercase(0)) Args:\nvalue (UInt8) Returns:\nBool"},"title":"is_ascii_uppercase"},"/ExtraMojo/extramojo/bstr/bstr/to_ascii_lowercase/":{"data":{"to_ascii_lowercase#\u003ccode\u003eto_ascii_lowercase\u003c/code\u003e":"Mojo function ü°≠\nto_ascii_lowercase ‚ûï¬† ‚ûñ fn to_ascii_lowercase(mut buffer: List[UInt8]) Lowercase all ascii a-zA-Z characters. from testing import assert_equal from extramojo.bstr.bstr import to_ascii_lowercase var test = List(\"ABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZ\".as_bytes()) var expected = List(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\".as_bytes()) to_ascii_lowercase(test) assert_equal(test, expected) Args:\nbuffer (List) "},"title":"to_ascii_lowercase"},"/ExtraMojo/extramojo/bstr/bstr/to_ascii_uppercase/":{"data":{"to_ascii_uppercase#\u003ccode\u003eto_ascii_uppercase\u003c/code\u003e":"Mojo function ü°≠\nto_ascii_uppercase ‚ûï¬† ‚ûñ fn to_ascii_uppercase(mut buffer: List[UInt8]) Uppercase all ascii a-zA-Z characters. from testing import assert_equal from extramojo.bstr.bstr import to_ascii_uppercase var test = List(\"ABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZABCdefgHIjklmnOPQRSTUVWXYZ\".as_bytes()) var expected = List(\"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\".as_bytes()) to_ascii_uppercase(test) assert_equal(test, expected) Args:\nbuffer (List) "},"title":"to_ascii_uppercase"},"/ExtraMojo/extramojo/bstr/memchr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = simd_width_of[DType.uint8]() LOOP_SIZE = (SIMD_U8_WIDTH * 4) ","functions#Functions":" memchr memchr_wide ","memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo module ü°≠\nmemchrFast memchr implementations.\nThere are two here, memchr and memchr_wide. memchr_wide will do more comparisons at once, but needs to do more loading first. If you know you have some distance between needles, then it should be faster. memchr is just vanilla memchr."},"title":"memchr"},"/ExtraMojo/extramojo/bstr/memchr/memchr/":{"data":{"memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo function ü°≠\nmemchr ‚ûï¬† ‚ûñ fn memchr[do_alignment: Bool = False](haystack: Span[UInt8, origin], chr: UInt8, start: Int = 0) -\u003e Int Function to find the next occurrence of character. from testing import assert_equal from extramojo.bstr.memchr import memchr assert_equal(memchr(\"enlivened,unleavened,Arnulfo's,Unilever's,unloved|Anouilh,analogue,analogy\".as_bytes(), ord(\"|\")), 49) Parameters:\ndo_alignment (Bool): If True this will do an aligning read at the very start of the haystack. If your haystack is very long, this may provide a marginal benefit. If the haystack is short, or the needle is frequently in the first SIMD_U8_WIDTH * 2 bytes, then skipping the aligning read can be very beneficial since the aligning read check will overlap some amount with the subsequent aligned read that happens next. Args:\nhaystack (Span): The bytes to search for the chr. chr (UInt8): The byte to search for. start (Int): The starting point to begin the search in haystack. Returns:\nInt: The index of the found character, or -1 if not found."},"title":"memchr"},"/ExtraMojo/extramojo/bstr/memchr/memchr_wide/":{"data":{"memchr_wide#\u003ccode\u003ememchr_wide\u003c/code\u003e":"Mojo function ü°≠\nmemchr_wide ‚ûï¬† ‚ûñ fn memchr_wide(haystack: Span[UInt8, origin], chr: UInt8, start: Int = 0) -\u003e Int Function to find the next occurrence of character. This function does more unrolling and will be faster if the search if over longer distances. If in doubt use memchr.\nfrom testing import assert_equal from extramojo.bstr.memchr import memchr_wide assert_equal(memchr_wide(\"enlivened,unleavened,Arnulfo's,Unilever's,unloved|Anouilh,analogue,analogy\".as_bytes(), ord(\"|\")), 49) Args:\nhaystack (Span): The bytes to search for the chr. chr (UInt8): The byte to search for. start (Int): The starting point to begin the search in haystack. Returns:\nInt: The index of the found character, or -1 if not found."},"title":"memchr_wide"},"/ExtraMojo/extramojo/cli/":{"data":{"cli#\u003ccode\u003ecli\u003c/code\u003e":"Mojo package ü°≠\ncliThe cli module contains functionality for creating and using command line applications.","modules#Modules":" parser: A very basic CLI Opt Parser. "},"title":"cli"},"/ExtraMojo/extramojo/cli/parser/":{"data":{"parser#\u003ccode\u003eparser\u003c/code\u003e":"Mojo module ü°≠\nparserA very basic CLI Opt Parser.\nfrom testing import assert_equal, assert_true from extramojo.cli.parser import OptParser, OptConfig, OptKind var args = List(String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\"), String(\"ExtraFile.tsv\")) var program_name = \"example\" var parser = OptParser(name=\"example\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) # Specify any needed arguments. If at least n arguments aren't found after parsing the opts, an exception will be raised. parser.expect_at_least_n_args(1, \"Additional files to process\") # Note, a user would call parser.parse_sys_args() var opts = parser.parse_args(args) assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) ","structs#Structs":" OptKind: The viable types for an option to have. OptValue: When an option is parsed, it‚Äôs stored as an OptValue. OptConfig: Create an option to be added to the OptParser. ParsedOpts: The parsed CLI options. Access your values with ParsedOpts.get_string(), ParsedOpts.get_int(), etc. OptParser: [OptParser] will try to parse your long-form CLI options. Subcommand: A subcommand. SubcommandParser: Subcommands are created by passing in the command, and an OptParser. "},"title":"parser"},"/ExtraMojo/extramojo/cli/parser/OptConfig/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" long_name (String): Required long name of, this will be used as the cli value as --long_name. default_value (Optional[String]): If there is one, the Stringified deafult value. This will be parsed via OptKind. value_kind (OptKind): The type of the value for this option. is_flag (Bool): If it‚Äôs a flag, then it‚Äôs value_kind needs to be Bool. description (String): Long for description, for best results, don‚Äôt add a newline. ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var long_name: String, value_kind: OptKind, *, is_flag: Bool = False, var description: String = \"\", var default_value: Optional[String] = None) Details Args:\nlong_name (String) value_kind (OptKind) is_flag (Bool) description (String) default_value (Optional) self (Self) Returns:\nSelf\nRaises:","optconfig#\u003ccode\u003eOptConfig\u003c/code\u003e":"Mojo struct ü°≠\nOptConfig @memory_only struct OptConfig Create an option to be added to the OptParser."},"title":"OptConfig"},"/ExtraMojo/extramojo/cli/parser/OptKind/":{"data":{"aliases#Aliases":" StringLike = OptKind(0) IntLike = OptKind(1) FloatLike = OptKind(2) BoolLike = OptKind(3) __del__is_trivial = True __moveinit__is_trivial = True __copyinit__is_trivial = True ","fields#Fields":" value (UInt8) ","implemented-traits#Implemented traits":"AnyType, Copyable, ImplicitlyCopyable, Movable, Stringable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, value: UInt8) Details Args:\nvalue (UInt8) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__str__ fn __str__(self) -\u003e String Details Args:\nself (Self) Returns:\nString","optkind#\u003ccode\u003eOptKind\u003c/code\u003e":"Mojo struct ü°≠\nOptKind @memory_only struct OptKind The viable types for an option to have."},"title":"OptKind"},"/ExtraMojo/extramojo/cli/parser/OptParser/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" options (Dict[String, OptConfig]): The options this will attempt to parse. program_description (String): The description of the program, to be used in the help message. program_name (String): Your programs name, to be used in the help message. min_num_args_expected (Optional[Int]): Whether or not to expect any program args, and if so, at least (\u003e=) how many. args_help_msg (String): Help message for arguments. ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, *, name: String, description: String = \"\") Details Args:\nname (String) description (String) self (Self) Returns:\nSelf\nRaises:\nexpect_at_least_n_args fn expect_at_least_n_args(mut self, n: Int, args_help_msg: String = \"\") The minimum number of args to expect. len(args) \u003e= min_num_args_expected\nIf not set, args are not checked.\nArgs:\nself (Self) n (Int) args_help_msg (String) add_opt fn add_opt(mut self, var arg: OptConfig) Add an [OptConfig]. Args:\nself (Self) arg (OptConfig) help_msg fn help_msg(self) -\u003e String Get the help message string based on the currently added options. Args:\nself (Self) Returns:\nString\nparse_sys_args fn parse_sys_args(mut self) -\u003e ParsedOpts Parse the arguments from sys.argv(). Args:\nself (Self) Returns:\nParsedOpts\nRaises:\nparse_args fn parse_args(self, args: List[String]) -\u003e ParsedOpts Parse the arguments passed in via args. Args:\nself (Self) args (List) Returns:\nParsedOpts\nRaises:","optparser#\u003ccode\u003eOptParser\u003c/code\u003e":"Mojo struct ü°≠\nOptParser @memory_only struct OptParser [OptParser] will try to parse your long-form CLI options."},"title":"OptParser"},"/ExtraMojo/extramojo/cli/parser/OptValue/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" kind (OptKind) ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, str_value: String = \"\") Details Args:\nstr_value (String) self (Self) Returns:\nSelf\nfn __init__(out self, int_value: Int = 0) Details Args:\nint_value (Int) self (Self) Returns:\nSelf\nfn __init__(out self, float_value: Float64 = 0) Details Args:\nfloat_value (Float64) self (Self) Returns:\nSelf\nfn __init__(out self, bool_value: Bool = False) Details Args:\nbool_value (Bool) self (Self) Returns:\nSelf\nget_string fn get_string(self) -\u003e Optional[String] Details Args:\nself (Self) Returns:\nOptional\nget_int fn get_int(self) -\u003e Optional[Int] Details Args:\nself (Self) Returns:\nOptional\nget_float fn get_float(self) -\u003e Optional[Float64] Details Args:\nself (Self) Returns:\nOptional\nget_bool fn get_bool(self) -\u003e Optional[Bool] Details Args:\nself (Self) Returns:\nOptional\nparse_string @staticmethod fn parse_string(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nparse_int @staticmethod fn parse_int(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_float @staticmethod fn parse_float(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_bool @staticmethod fn parse_bool(value: String) -\u003e Self Details Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_kind @staticmethod fn parse_kind(kind: OptKind, value: String) -\u003e Self Parse the string based on the value of OptKind. Args:\nkind (OptKind) value (String) Returns:\nSelf\nRaises:","optvalue#\u003ccode\u003eOptValue\u003c/code\u003e":"Mojo struct ü°≠\nOptValue @memory_only struct OptValue When an option is parsed, it‚Äôs stored as an OptValue.\nTo get concrete values out of the ParsedOpts prefer to use the ParsedOpts.get_\u003ctype\u003e() methods."},"title":"OptValue"},"/ExtraMojo/extramojo/cli/parser/ParsedOpts/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" options (Dict[String, OptValue]) args (List[String]) help_msg (String) ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var help_msg: String = \"\") Details Args:\nhelp_msg (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(ref self) -\u003e Pointer[String, origin_of(self_is_origin.help_msg)] Get a nicely formatted help string. Args:\nself (Self) Returns:\nPointer\nget_string fn get_string(self, key: String) -\u003e String Try to get the option specified with the given key as a String. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nString\nRaises:\nget_int fn get_int(self, key: String) -\u003e Int Try to get the option specified with the given key as an Int. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nInt\nRaises:\nget_float fn get_float(self, key: String) -\u003e Float64 Try to get the option specified with the given key as a Float64. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nFloat64\nRaises:\nget_bool fn get_bool(self, key: String) -\u003e Bool Try to get the option specified with the given key as a Bool. This will raise if the key is not found, or if the type of the option doesn‚Äôt match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nBool\nRaises:","parsedopts#\u003ccode\u003eParsedOpts\u003c/code\u003e":"Mojo struct ü°≠\nParsedOpts @memory_only struct ParsedOpts The parsed CLI options. Access your values with ParsedOpts.get_string(), ParsedOpts.get_int(), etc.\nAccess CLI arguments from ParsedOpts.args. Get the help message with ParsedOpts.get_help_message.\nNote that there is an automatic help flag added to your options, it can be overridden by another option with that same name. The input args are first scanned for ‚Äú‚Äìhelp‚Äù and if that is found the parser will exit early, returning the parsed value of the ‚Äú‚Äìhelp‚Äù flag (or option if you have overridden it). It is up to the user to check for the ‚Äúhelp‚Äù option being set and print the help message."},"title":"ParsedOpts"},"/ExtraMojo/extramojo/cli/parser/Subcommand/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" parser (OptParser) ","implemented-traits#Implemented traits":"AnyType, Copyable, Hashable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var parser: OptParser) Details Args:\nparser (OptParser) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Details Args:\nself (Self) other (Self) Returns:\nBool\n__hash__ fn __hash__[H: Hasher](self, mut hasher: H) Details Parameters:\nH (Hasher) Args:\nself (Self) hasher (H) ","subcommand#\u003ccode\u003eSubcommand\u003c/code\u003e":"Mojo struct ü°≠\nSubcommand @memory_only struct Subcommand A subcommand.\nThe name of the subcommand is the OptParser.name. The name of the subcommand will be checked against the first value in the input args. The help message will display the program description for the OptParser that is associated with this subcommand."},"title":"Subcommand"},"/ExtraMojo/extramojo/cli/parser/SubcommandParser/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = False ","fields#Fields":" commands (Dict[String, Subcommand]) description (String) name (String) ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, *, var name: String, var description: String = \"\") Details Args:\nname (String) description (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(self) -\u003e String Create the help message for the subcommands. Args:\nself (Self) Returns:\nString\nRaises:\nadd_command fn add_command(mut self, command: Subcommand) Add a subcommand. Args:\nself (Self) command (Subcommand) parse_args fn parse_args(self, args: List[String]) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the input args, expecting a subcommand. Args:\nself (Self) args (List) Returns:\nOptional\nRaises:\nparse_sys_args fn parse_sys_args(self) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the sys.argv() list. Args:\nself (Self) Returns:\nOptional\nRaises:","subcommandparser#\u003ccode\u003eSubcommandParser\u003c/code\u003e":"Mojo struct ü°≠\nSubcommandParser @memory_only struct SubcommandParser Subcommands are created by passing in the command, and an OptParser.\nThe parser is for the options for the subcommand.\nfrom testing import assert_equal, assert_true from extramojo.cli.parser import OptParser, OptConfig, OptKind, SubcommandParser, Subcommand var args = List(String(\"do-work\"), String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\")) var program_name = \"example\" var parser = OptParser(name=\"do-work\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) var cmd = Subcommand(parser^) # uses the name from the passed in parser var cmd_parser = SubcommandParser(name=String(\"cool-program\"), description=\"Do some cool stuff.\") cmd_parser.add_command(cmd) # Note, a user would call parser.parse_sys_args() var cmd_and_opts = cmd_parser.parse_args(args) if not cmd_and_opts: print(cmd_parser.get_help_message()) var parsed = cmd_and_opts.value() var parsed_cmd = parsed[0] var opts = parsed[1].copy() if parsed_cmd == cmd.parser.program_name: assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) "},"title":"SubcommandParser"},"/ExtraMojo/extramojo/collections/":{"data":{"collections#\u003ccode\u003ecollections\u003c/code\u003e":"Mojo package ü°≠\ncollections","modules#Modules":" bitvec: Provides a growable bitfield. ","packages#Packages":" bbhash "},"title":"collections"},"/ExtraMojo/extramojo/collections/bbhash/":{"data":{"bbhash#\u003ccode\u003ebbhash\u003c/code\u003e":"Mojo package ü°≠\nbbhash","modules#Modules":" bbhash: Provides a BBHash implementation. hash: Hash functions. "},"title":"bbhash"},"/ExtraMojo/extramojo/collections/bbhash/bbhash/":{"data":{"aliases#Aliases":" MAX_ITERS = 100 ","bbhash#\u003ccode\u003ebbhash\u003c/code\u003e":"Mojo module ü°≠\nbbhashProvides a BBHash implementation.","examples#Examples":" from testing import assert_true, assert_false from extramojo.collections.bbhash.bbhash import BBHash var keys: List[String] = [\"fox\", \"cat\", \"dog\", \"mouse\", \"frog\"] var bbset = BBHash(keys^, gamma=1.0) assert_true(bbset.find(String(\"fox\"))) assert_false(bbset.find(String(\"muffin\"))) Verify that a returned True value for key matches the key from the original input set:\nfrom hashlib.hash import hash from testing import assert_true, assert_false from extramojo.collections.bbhash.bbhash import BBHash var keys: List[String] = [\"fox\", \"cat\", \"dog\", \"mouse\", \"frog\"] var bbset = BBHash[True](keys^, gamma=1.0) var idx = bbset.find(String(\"fox\")) var key_hash = bbset.key(idx) assert_true(key_hash.value() == hash(String(\"fox\"))) ","references#References:":" https://github.com/relab/bbhash https://arxiv.org/abs/1702.03154 ","structs#Structs":" BBHash: BBHash represents a minimal perfect hash for a set of keys. "},"title":"bbhash"},"/ExtraMojo/extramojo/collections/bbhash/bbhash/BBHash/":{"data":{"aliases#Aliases":" __del__is_trivial = False ","bbhash#\u003ccode\u003eBBHash\u003c/code\u003e":"Mojo struct ü°≠\nBBHash @memory_only struct BBHash[compute_reverse_map: Bool = False] BBHash represents a minimal perfect hash for a set of keys.","fields#Fields":" bits (List[BitVec]) ranks (List[UInt64]) reverse_map (List[UInt64]) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__[K: Copyable \u0026 Movable \u0026 Hashable](out self, var keys: List[K], *, gamma: Float64 = 1) Create a BBHash. Parameters:\nK (Copyable \u0026 Movable \u0026 Hashable) Args:\nkeys (List): The keys to create a minimal perfect hash for. gamma (Float64): Tunable param for optimizing between storage size and creation/lookup speed. 1.0 will give the best size, larger will result in faster lookups and creation. See publication for details. self (Self) Returns:\nSelf\nfind fn find[K: Hashable](self, key: K) -\u003e UInt64 Find returns a unique index representing the key in the minimal hash set. The return value is meaningful ONLY for keys in the original key set (provided at the time of construction of the minimal hash set).\nIf the key is in the original key set, the return value is guaranteed to be in the range [1, len(keys)].\nIf the key is not in the original key set, two things can happen:\nThe return value is 0, representing that the key was not in the original key set. The return value is in the expected range [1, len(keys)], but is a false positive. In other words, find can return false positives and if ‚Äúwithin set‚Äù is your question you should then validate the key via the key function to ensure that the found key matches the input key.\nParameters:\nK (Hashable) Args:\nself (Self) key (K): The hashable key to check membership for. Returns:\nUInt64: The unique index of the key, or 0 if it isn‚Äôt in the set.\nkey fn key(self, idx: UInt64) -\u003e Optional[UInt64] Get the hash of the key associated with the given index. Args:\nself (Self) idx (UInt64): The index given by find for a key. Returns:\nOptional: The hash of the key associated with the index, or None if the idx is invalid.","parameters#Parameters":" compute_reverse_map (Bool): If True, compute the reverse_map which allows looking up the original key based off an index. "},"title":"BBHash"},"/ExtraMojo/extramojo/collections/bbhash/hash/":{"data":{"aliases#Aliases":" m = 9800771712469244261 FNV_OFFSET = 14695981039346656037 FNV_PRIME = 1099511628211 ","functions#Functions":" fnv1a ","hash#\u003ccode\u003ehash\u003c/code\u003e":"Mojo module ü°≠\nhashHash functions.\nThese are all for BBHash, with the exception of fnv1a."},"title":"hash"},"/ExtraMojo/extramojo/collections/bbhash/hash/fnv1a/":{"data":{"fnv1a#\u003ccode\u003efnv1a\u003c/code\u003e":"Mojo function ü°≠\nfnv1a ‚ûï¬† ‚ûñ fn fnv1a(buf: Span[UInt8, origin]) -\u003e UInt64 Classic FNV1a hash function. Args:\nbuf (Span) Returns:\nUInt64"},"title":"fnv1a"},"/ExtraMojo/extramojo/collections/bitvec/":{"data":{"bitvec#\u003ccode\u003ebitvec\u003c/code\u003e":"Mojo module ü°≠\nbitvecProvides a growable bitfield.\nOptimized for space (1 bit per element) and speed (O(1) operations). Offers set/clear/test/toggle and fast population count. The underlying storage grows automatically but does not shrink unless shrink_to_fit is called (not implemented yet).\nExample:\nvar bv = BitVec(length=128, fill=False) # 128-bit set, all clear bv.set(42) # Mark value 42 as present. if bv[42]: # Check membership, could use bv.test(42) print(\"hit\") # Prints \"hit\". bv.clear(42) # Remove 42. print(bv.count_set_bits()) # Prints 0. ","structs#Structs":" BitVec: A growable bitfield. "},"title":"bitvec"},"/ExtraMojo/extramojo/collections/bitvec/BitVec/":{"data":{"#":"Mojo struct ü°≠\nBitVec @memory_only struct BitVec A growable bitfield.\nThis uses one bit per bool for storage.\nThe bits are stored in Self.WORD_DTYPE words. This is optimized for compactness and speed.\nAliases WORD_DTYPE = DType.uint64 if (is_gpu().__bool__() ^ True) else DType.uint32 WORD_BYTEWIDTH = (bit_width_of[BitVec.WORD_DTYPE]() // 8) WORD = Scalar[BitVec.WORD_DTYPE] __del__is_trivial = False __moveinit__is_trivial = False __copyinit__is_trivial = True Fields data (UnsafePointer[Scalar[BitVec.WORD_DTYPE], origin_of(MutOrigin.external)]): The data storage. Implemented traits AnyType, Boolable, Copyable, Movable, Sized, UnknownDestructibility, Writable\nMethods ‚ûï¬† ‚ûñ __init__ fn __init__(out self) Details Args:\nself (Self) Returns:\nSelf\nfn __init__(out self, *, capacity: UInt) Capacity measured in bits. Args:\ncapacity (UInt) self (Self) Returns:\nSelf\nfn __init__(out self, *, length: UInt, fill: Bool = False) Create a new bitvec with a known length and fill. Args:\nlength (UInt): Known length in bits. fill (Bool): The value to fill the bitvec with. self (Self) Returns:\nSelf\nfn __init__(out self, var *values: Bool, *, __list_literal__: Tuple[] = Tuple[]()) Constructs a BitVec from the given values. Args:\n*values (Bool): The values to populate the BitVec with. list_literal (Tuple): Tell Mojo to use this method for list literals. self (Self) Returns:\nSelf\nfn __init__(out self, *, var elements: VariadicListMem[Bool, origin, is_owned]) Constructs a BitVec from the given values. Args:\nelements (VariadicListMem): The values to populate the list with. self (Self) Returns:\nSelf\n__moveinit__ @staticmethod fn __moveinit__(out self, var other: Self) Details Args:\nother (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(var self) Details Args:\nself (Self) __bool__ fn __bool__(self) -\u003e Bool Checks if the BitVec is non-empty (contains at least one value). Equivalent to len(self) != 0 or not self.is_empty().\nArgs:\nself (Self) Returns:\nBool: True if at least one value is in BitVec., False otherwise.\n__getitem__ fn __getitem__(self, idx: UInt) -\u003e Bool Get the bit at the given index. Args:\nself (Self) idx (UInt): The index of the bit. Returns:\nBool\n__setitem__ fn __setitem__(mut self, idx: UInt, value: Bool) Set the bit at the given index. Args:\nself (Self) idx (UInt): The index of the bit to set. value (Bool): The value to set the bit to. __eq__ fn __eq__(self, other: Self) -\u003e Bool Check the equality of self and other. Args:\nself (Self) other (Self): The BitVec to compare against. Returns:\nBool: True if equal, False otherwise.\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Check the equality of self and other. Args:\nself (Self) other (Self): The BitVec to compare against. Returns:\nBool: True if not equal, False otherwise.\n__sub__ fn __sub__(self, other: Self) -\u003e Self Returns a new BitVec that is the difference of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 -: 0 0 0 1 1 1 1 0 Args:\nself (Self) other (Self): The BitVec to subtract from self. Returns:\nSelf: A new BitVec containing elements from self that are not in other.\n__and__ fn __and__(self, other: Self) -\u003e Self Returns a new BitVec that is the intersection of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 \u0026: 0 0 1 0 0 0 0 0 Args:\nself (Self) other (Self): The BitVec to intersect with. Returns:\nSelf: A new BitVec containing only the elements present in both sets.\n__or__ fn __or__(self, other: Self) -\u003e Self Returns a new BitVec that is the union of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 |: 1 1 1 1 1 1 1 0 Args:\nself (Self) other (Self): The BitVec to union with. Returns:\nSelf: A new BitVec containing all elements from both sets.\n__isub__ fn __isub__(mut self, other: Self) Modifies self to be the difference of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 -= 0 0 0 1 1 1 1 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s.\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to subtract from self. __iand__ fn __iand__(mut self, other: Self) Modifies self to be the intersection of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 \u0026= 0 0 1 0 0 0 0 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s.\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to intersect with. __ior__ fn __ior__(mut self, other: Self) Modifies self to be the union of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 |= 1 1 1 1 1 1 1 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to union with. copy fn copy(self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int The number of bits in the bitvec. Args:\nself (Self) Returns:\nInt\ncapacity fn capacity(self) -\u003e UInt Returns the capacity in bits. Args:\nself (Self) Returns:\nUInt\nword_len fn word_len(self) -\u003e UInt Get the number of words that have been set. Args:\nself (Self) Returns:\nUInt\nis_empty fn is_empty(self) -\u003e Bool Checks if the BitVec has any values stored in it. Equivalent to len(self) == 0. Note that this checks the logical size, not the allocated capacity.\nArgs:\nself (Self) Returns:\nBool: True if no values are stored in the BitVec.\nresize fn resize(mut self, new_size: UInt, fill: Bool) Resize the bitvec, filling any new size with fill. Args:\nself (Self) new_size (UInt): The new size in bits. fill (Bool): The value to use to populate new elements. shrink fn shrink(mut self, new_size: UInt) Resizes to the given new size (in bits) which must be \u003c= the current size. Notes: With no new value provided, the new size must be smaller than or equal to the current one. Elements at the end are discarded.\nArgs:\nself (Self) new_size (UInt): The new size in bits. reserve fn reserve(mut self, new_capacity: UInt) Reserves the requested capacity (in bits). Notes: If the current capacity is greater or equal, this is a no-op. Otherwise, the storage is reallocated and the data is moved.\nArgs:\nself (Self) new_capacity (UInt): The new capacity, in bits. test fn test(self, idx: UInt) -\u003e Bool Tests if the bit at the specified index idx is set (is 1). Aborts if idx is negative or greater than or equal to the compile-time size.\nArgs:\nself (Self) idx (UInt): The non-negative index of the bit to test (must be \u003c size). Returns:\nBool: True if the bit at idx is set, False otherwise.\nclear fn clear(mut self) Clear the BitVec. This sets the length to 0.\nArgs:\nself (Self) fn clear(mut self, idx: UInt) Clear the bit at the given index (set to 0). Args:\nself (Self) idx (UInt): The index of the bit to clear. zero_all fn zero_all(mut self) Set all bits to zero. Args:\nself (Self) set_and_check fn set_and_check(mut self, idx: UInt) -\u003e Bool Set the bit at the given index. If the value was already set, return False, otherwise True. Args:\nself (Self) idx (UInt): The index of the bit to set. Returns:\nBool: False if the bit was already set, True if it was not.\nset fn set(mut self, idx: UInt) Set the bit at the given index to 1. Args:\nself (Self) idx (UInt): The index of the bit to set. clear_and_check fn clear_and_check(mut self, idx: UInt) -\u003e Bool Clear the bit at the given index. If the value was already clear (0, False), return False, otherwise True. Args:\nself (Self) idx (UInt): The index of the bit to clear. Returns:\nBool: False if the bit was already clear, True if it was not.\ntoggle fn toggle(mut self, idx: UInt) Toggles (inverts) the bit at the specified index idx. Args:\nself (Self) idx (UInt): The non-negative index of the bit to toggle (must be \u003c len(BitVec)). append fn append(mut self, value: Bool) Append an item to the end of the BitVec. Notes: If there is no capacity left, resizes to twice the current capacity. Except for 0 capacity where it sets to 1.\nArgs:\nself (Self) value (Bool): The value to append. append_true fn append_true(mut self) Append a set bit to the end of the BitVec. Notes: If there is no capacity left, resizes to twice the current capacity. Except for 0 capacity where it sets to 1.\nArgs:\nself (Self) append_false fn append_false(mut self) Append a cleared bit to the end of the BitVec. Notes: If there is no capacity left, resizes to twice the current capacity. Except for 0 capacity where it sets to 1.\nArgs:\nself (Self) pop_back fn pop_back(mut self) -\u003e Bool Remove and return the last item in the BitVec. Args:\nself (Self) Returns:\nBool\ncount_set_bits fn count_set_bits(self) -\u003e UInt Count the total number of set bits. Args:\nself (Self) Returns:\nUInt\nrank fn rank(self, bit_idx: UInt) -\u003e UInt Count the total number of set bits up to (but not including) bit_idx. TODO: implement another struct that builds a rank/select index.\nReferences: https://rob-p.github.io/CMSC858D/static_files/presentations/CMSC858D-Lec08.pdf Args:\nself (Self) bit_idx (UInt): Index to get the rank for. Returns:\nUInt\ncount_clear_bits fn count_clear_bits(self) -\u003e UInt Count the total number of clear bits. Args:\nself (Self) Returns:\nUInt\nunion fn union(self, other: Self) -\u003e Self Returns a new BitVec that is the union of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 |: 1 1 1 1 1 1 1 0 Args:\nself (Self) other (Self): The BitVec to union with. Returns:\nSelf: A new BitVec containing all elements from both sets.\nintersection fn intersection(self, other: Self) -\u003e Self Returns a new BitVec that is the intersection of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 \u0026: 0 0 1 0 0 0 0 0 Args:\nself (Self) other (Self): The BitVec to intersect with. Returns:\nSelf: A new BitVec containing only the elements present in both sets.\ndifference fn difference(self, other: Self) -\u003e Self Returns a new BitVec that is the difference of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 -: 0 0 0 1 1 1 1 0 Args:\nself (Self) other (Self): The BitVec to subtract from self. Returns:\nSelf: A new BitVec containing elements from self that are not in other.\nunion_update fn union_update(mut self, other: Self) Modifies self to be the union of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 |= 1 1 1 1 1 1 1 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to union with. intersection_update fn intersection_update(mut self, other: Self) Modifies self to be the intersection of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 \u0026= 0 0 1 0 0 0 0 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s.\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to intersect with. difference_update fn difference_update(mut self, other: Self) Modifies self to be the difference of self and other. A: 0 0 1 1 1 1 1 0 B: 1 1 1 0 0 -= 0 0 0 1 1 1 1 0 If len(self) \u003c len(other), self will be resized to match the size of other by filling with 0s.\nNotes: This retains selfs length.\nArgs:\nself (Self) other (Self): The BitVec to subtract from self. write_to fn write_to[W: Writer](self, mut writer: W) Write the bitvec in a nice format. Parameters:\nW (Writer) Args:\nself (Self) writer (W) ","aliases#Aliases":"","bitvec#\u003ccode\u003eBitVec\u003c/code\u003e":"","fields#Fields":"","implemented-traits#Implemented traits":"","methods#Methods":"","references#References:":""},"title":"BitVec"},"/ExtraMojo/extramojo/io/":{"data":{"io#\u003ccode\u003eio\u003c/code\u003e":"Mojo package ü°≠\nioIO.","modules#Modules":" buffered: Buffered reading and writing. delimited: Working with simple delimited text. "},"title":"io"},"/ExtraMojo/extramojo/io/buffered/":{"data":{"aliases#Aliases":" NEW_LINE = 10 SIMD_U8_WIDTH = simd_width_of[DType.uint8]() BUF_SIZE = 131072 ","buffered#\u003ccode\u003ebuffered\u003c/code\u003e":"Mojo module ü°≠\nbufferedBuffered reading and writing.","examples#Examples":"BufferedReader:\nfrom testing import assert_equal from extramojo.io.buffered import BufferedReader fn test_read_until(file: String, expected_lines: List[String]) raises: var buffer_capacities = List(10, 100, 200, 500) for cap in buffer_capacities: var fh = open(file, \"r\") var reader = BufferedReader(fh^, buffer_capacity=cap) var buffer = List[UInt8]() var counter = 0 while reader.read_until(buffer) != 0: assert_equal(List(expected_lines[counter].as_bytes()), buffer) counter += 1 buffer.clear() assert_equal(counter, len(expected_lines)) print(String(\"Successful read_until with buffer capacity of {}\").format(cap)) BufferedWriter:\nfrom extramojo.io.buffered import BufferedWriter fn test_buffered_writer(file: String, expected_lines: List[String]) raises: var fh = BufferedWriter(open(String(file), \"w\"), buffer_capacity=128) for i in range(len(expected_lines)): fh.write_bytes(expected_lines[i].as_bytes()) fh.write_bytes(\" \".as_bytes()) fh.flush() fh.close() test_read_until(String(file), expected_lines) ","functions#Functions":" read_lines for_each_line get_next_line ","structs#Structs":" BufferedReader: BufferedReader for readying lines and bytes from a file in a buffered way. BufferedWriter: A BufferedWriter. "},"title":"buffered"},"/ExtraMojo/extramojo/io/buffered/BufferedReader/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False ","bufferedreader#\u003ccode\u003eBufferedReader\u003c/code\u003e":"Mojo struct ü°≠\nBufferedReader @memory_only struct BufferedReader BufferedReader for readying lines and bytes from a file in a buffered way.","example#Example":" from extramojo.io.buffered import BufferedReader fn read_bytes(read file: String) raises -\u003e List[UInt8]: var fh = open(file, \"r\") var reader = BufferedReader(fh^, buffer_capacity=50) var buffer = List[UInt8](capacity=125) for _ in range(0, 125): buffer.append(0) var found_file = List[UInt8]() # Read bytes from the buf reader, copy to found var bytes_read = 0 while True: bytes_read = reader.read_bytes(buffer) if bytes_read == 0: break found_file.extend(buffer[0:bytes_read]) return found_file^ ","fields#Fields":" fh (FileHandle): The internal filehandle to read from. buffer (UnsafePointer[UInt8, origin_of(MutOrigin.external)]): The internal buffer. file_offset (Int): Current offset into the file. buffer_offset (Int): Current offset into the buffer. buffer_capacity (Int): Total capacity of the buffer. buffer_len (Int): Total filled capacity of the buffer. ","implemented-traits#Implemented traits":"AnyType, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var fh: FileHandle, buffer_capacity: Int = BUF_SIZE) Create a BufferedReader. Args:\nfh (FileHandle): The filehandle to read from. buffer_capacity (Int): The size of the buffer to use. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, var existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(var self) Details Args:\nself (Self) __enter__ fn __enter__(var self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nread_bytes fn read_bytes(mut self, mut buffer: List[UInt8]) -\u003e Int Read up to len(buffer) bytes. Args:\nself (Self) buffer (List): The buffer to read into. The len of the buffer determines how many bytes will be read. Returns:\nInt: This returns the number of bytes read. If the number of bytes read is less then len(buffer) then EOF has been reached.\nRaises:\nread_until fn read_until(mut self, mut buffer: List[UInt8], char: UInt = 10) -\u003e Int Fill the given line_buffer until the given char is hit, or EOF. Note: the callee is responsible for clearing (or not) the buffer between calls to read_until.\nArgs:\nself (Self) buffer (List): The buffer to filled with any bytes found before char is hit. char (UInt): The character to use as the terminator. Returns:\nInt: The number of bytes read.\nRaises:"},"title":"BufferedReader"},"/ExtraMojo/extramojo/io/buffered/BufferedWriter/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False ","bufferedwriter#\u003ccode\u003eBufferedWriter\u003c/code\u003e":"Mojo struct ü°≠\nBufferedWriter @memory_only struct BufferedWriter[W: Movable \u0026 Writer] A BufferedWriter.\n## Example ```mojo from extramojo.io.buffered import BufferedWriter fn write_to_file(read file: String, read expected_lines: List[String]) raises: var fh = BufferedWriter(open(String(file), \"w\"), buffer_capacity=128) for i in range(len(expected_lines)): fh.write_bytes(expected_lines[i].as_bytes()) fh.write_bytes(\" ‚Äú.as_bytes()) fh.flush() fh.close() ```","fields#Fields":" inner (W): The inner file handle to write to. buffer (List[UInt8]): The inner buffer. buffer_capacity (Int): The capacity of the inner buffer. buffer_len (Int): The number of bytes currently stored in the inner buffer. ","implemented-traits#Implemented traits":"AnyType, Movable, UnknownDestructibility, Writer","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var writer: W, buffer_capacity: Int = BUF_SIZE) Create a BufferedReader. Args:\nwriter (W): The writer to write to. buffer_capacity (Int): The capacity of the inner buffer to use. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, var existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(var self) Details Args:\nself (Self) __enter__ fn __enter__(var self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nclose fn close(mut self) Details Args:\nself (Self) Raises:\nwrite_bytes fn write_bytes(mut self, bytes: Span[UInt8, origin]) Write bytes to this writer. Args:\nself (Self) bytes (Span): The bytes that will be written to the underlying buffer. write fn write[*Ts: Writable](mut self, *args: *Ts) Implement write. Parameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts): Any Writable values that will be written to the writer. flush fn flush(mut self) Write any remaining bytes in the current buffer, then clear the buffer. Args:\nself (Self) ","parameters#Parameters":" W (Movable \u0026 Writer) "},"title":"BufferedWriter"},"/ExtraMojo/extramojo/io/buffered/for_each_line/":{"data":{"for_each_line#\u003ccode\u003efor_each_line\u003c/code\u003e":"Mojo function ü°≠\nfor_each_line ‚ûï¬† ‚ûñ fn for_each_line[func: fn[?, mut`: Bool, origin`1: Origin[mut]](Span[UInt8, origin], Int, Int) capturing -\u003e None](path: String, buf_size: Int = BUF_SIZE) Call the provided callback on each line. The callback will be given a buffer, and the [start, end) of where the line is in that buffer.\nParameters:\nfunc (fn[?, mut: Bool, origin1: Origin[mut]](Span[UInt8, origin], Int, Int) capturing -\u003e None): The callback to run for each line. Args:\npath (String): The file path to open and read. buf_size (Int): The size of the buffer to use. Raises:"},"title":"for_each_line"},"/ExtraMojo/extramojo/io/buffered/get_next_line/":{"data":{"get_next_line#\u003ccode\u003eget_next_line\u003c/code\u003e":"Mojo function ü°≠\nget_next_line ‚ûï¬† ‚ûñ fn get_next_line[is_mutable: Bool, //, origin: Origin[is_mutable]](buffer: Span[UInt8, origin], start: Int) -\u003e Span[UInt8, origin] Function to get the next line using either SIMD instruction (default) or iteratively. Parameters:\nis_mutable (Bool) origin (Origin) Args:\nbuffer (Span): The buffer to search for the next newline character. start (Int): The start position to use inside the buffer. Returns:\nSpan: A span of bytes from [start, newline)."},"title":"get_next_line"},"/ExtraMojo/extramojo/io/buffered/read_lines/":{"data":{"read_lines#\u003ccode\u003eread_lines\u003c/code\u003e":"Mojo function ü°≠\nread_lines ‚ûï¬† ‚ûñ fn read_lines(path: String, buf_size: Int = BUF_SIZE) -\u003e List[List[UInt8]] Read all the lines in the file and return them as a List of Lists of bytes. Args:\npath (String): The file path to open and read. buf_size (Int): The size of the buffer to use. Returns:\nList: A list of lines, where each line is a List[UInt8].\nRaises:"},"title":"read_lines"},"/ExtraMojo/extramojo/io/delimited/":{"data":{"delimited#\u003ccode\u003edelimited\u003c/code\u003e":"Mojo module ü°≠\ndelimitedWorking with simple delimited text.","example#Example":"Compile-time known fields:\nTODO: this should be two different examples, but the doc parser can‚Äôt seem to handle that for this example.\nfrom collections.string import StringSlice from testing import assert_equal from extramojo.bstr.bstr import SplitIterator from extramojo.cli.parser import ParsedOpts from extramojo.io.buffered import ( BufferedReader, BufferedWriter, ) from extramojo.io.delimited import ( DelimReader, FromDelimited, ToDelimited, DelimWriter, ) # ######################################### # Example with compile-time known fields. # ######################################### @value struct SerDerStruct(ToDelimited, FromDelimited): var index: Int var name: String fn write_to_delimited(read self, mut writer: DelimWriter) raises: writer.write_record(self.index, self.name) fn write_header(read self, mut writer: DelimWriter) raises: writer.write_record(\"index\", \"name\") @staticmethod fn from_delimited(mut data: SplitIterator, read header_values: Optional[List[String]]=None) raises -\u003e Self: var index = Int(StringSlice(unsafe_from_utf8=data.__next__())) var name = String() # String constructor expected nul terminated byte span name.write_bytes(data.__next__()) return Self(index, name) fn test_delim_reader_writer(file: String) raises: var to_write = List[SerDerStruct]() for i in range(0, 1000): to_write.append(SerDerStruct(i, String(\"MyNameIs\" + String(i)))) var writer = DelimWriter( BufferedWriter(open(String(file), \"w\")), delim=\"\t\", write_header=True ) for item in to_write: writer.serialize(item) writer.flush() writer.close() var reader = DelimReader[SerDerStruct]( BufferedReader(open(String(file), \"r\")), delim=ord(\"\t\"), has_header=True, ) var count = 0 for item in reader^: assert_equal(to_write[count].index, item.index) assert_equal(to_write[count].name, item.name) count += 1 assert_equal(count, len(to_write)) # ######################################### # Example with dynamic fields. # ######################################### @value struct Score[ truth_lengths_origin: ImmutableOrigin, truth_names_origin: ImmutableOrigin, ](ToDelimited): var assembly_name: String var assembly_length: Int var scores: List[Int32] var truth_lengths: Pointer[List[Int], truth_lengths_origin] var truth_names: Pointer[List[String], truth_names_origin] fn __init__( out self, var assembly_name: String, assembly_length: Int, var scores: List[Int32], ref [truth_lengths_origin]truth_lengths: List[Int], ref [truth_names_origin]truth_names: List[String], ): self.assembly_name = assembly_name^ self.assembly_length = assembly_length self.scores = scores^ self.truth_lengths = Pointer(to=truth_lengths) self.truth_names = Pointer(to=truth_names) fn write_to_delimited(read self, mut writer: DelimWriter) raises: writer.write_field(self.assembly_name, is_last=False) writer.write_field(self.assembly_length, is_last=False) for i in range(0, len(self.scores)): writer.write_field( String(\"{}/{}\").format(self.scores[i], self.truth_lengths[][i]), is_last=i == len(self.scores) - 1, ) fn write_header(read self, mut writer: DelimWriter) raises: writer.write_field(\"assembly_name\", is_last=False) writer.write_field(\"assembly_length\", is_last=False) for i in range(0, len(self.truth_names[])): writer.write_field( self.truth_names[][i], is_last=i == len(self.truth_names[]) - 1 ) fn run_check_scores(opts: ParsedOpts) raises: var truth_names = List(String(\"A\"), String(\"B\"), String(\"C\")) var truth_lengths = List(125, 2000, 1234) var output_scores_tsv = \"/tmp/out.tsv\" var scores = List( Score(String(\"Assembly1\"), 100, List[Int32](1, 2, 3), truth_lengths, truth_names), Score(String(\"Assembly2\"), 100, List[Int32](100, 2, 3), truth_lengths, truth_names), Score(String(\"Assembly3\"), 100, List[Int32](1, 100, 3), truth_lengths, truth_names), Score(String(\"Assembly4\"), 100, List[Int32](1, 2, 100), truth_lengths, truth_names) ) var out_writer = DelimWriter( BufferedWriter(open(output_scores_tsv, \"w\")), delim=\"\t\", write_header=True, ) for score in scores: out_writer.serialize[ Score[__origin_of(truth_lengths), __origin_of(truth_names)] ](score) out_writer.flush() out_writer.close() # ######################################### # Example similar to dictreader/dictwriter. # ######################################### @value struct ThinWrapper(ToDelimited, FromDelimited): var stuff: Dict[String, Int] fn write_to_delimited(read self, mut writer: DelimWriter) raises: var seen = 1 for value in self.stuff.values(): # Relying on stable iteration order writer.write_field(value, is_last=seen == len(self.stuff)) seen += 1 fn write_header(read self, mut writer: DelimWriter) raises: var seen = 1 for header in self.stuff.keys(): # Relying on stable iteration order writer.write_field(header, is_last=seen == len(self.stuff)) seen += 1 @staticmethod fn from_delimited( mut data: SplitIterator, read header_values: Optional[List[String]] = None, ) raises -\u003e Self: var result = Dict[String, Int]() for header in header_values.value(): result[header] = Int( StringSlice(unsafe_from_utf8=data.__next__()) ) return Self(result) fn test_delim_reader_writer_dicts(file: String) raises: var to_write = List[ThinWrapper]() var headers = List( String(\"a\"), String(\"b\"), String(\"c\"), String(\"d\"), String(\"e\") ) for i in range(0, 1000): var stuff = Dict[String, Int]() for header in headers: stuff[header] = i to_write.append(ThinWrapper(stuff)) var writer = DelimWriter( BufferedWriter(open(String(file), \"w\")), delim=\"\t\", write_header=True, ) for item in to_write: writer.serialize(item) writer.flush() writer.close() var reader = DelimReader[ThinWrapper]( BufferedReader(open(String(file), \"r\")), delim=ord(\"\t\"), has_header=True, ) var count = 0 for item in reader^: for header in headers: assert_equal(to_write[count].stuff[header], item.stuff[header]) count += 1 assert_equal(count, len(to_write)) print(\"Successful delim_writer\") ","structs#Structs":" DelimReader: Read delimited data that is delimited by a single bytes. DelimWriter: Write delimited data. ","traits#Traits":" FromDelimited: Create an instance of Self from the iterator over Span[UInt8] bytes. ToDelimited "},"title":"delimited"},"/ExtraMojo/extramojo/io/delimited/DelimReader/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False ","delimreader#\u003ccode\u003eDelimReader\u003c/code\u003e":"Mojo struct ü°≠\nDelimReader @memory_only struct DelimReader[RowType: FromDelimited] Read delimited data that is delimited by a single bytes.\nThe RowType must implement FromBytes which is passed an iterator over the split up line.","fields#Fields":" delim (UInt8) reader (BufferedReader) next_elem (Optional[RowType]) buffer (List[UInt8]) len (Int) has_header (Bool) header_values (Optional[List[String]]) ","implemented-traits#Implemented traits":"AnyType, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var reader: BufferedReader, *, delim: UInt8, has_header: Bool) Details Args:\nreader (BufferedReader) delim (UInt8) has_header (Bool) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, var existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Details Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Details Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e RowType Details Args:\nself (Self) Returns:\nRowType\nRaises:\n__iter__ fn __iter__(var self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf","parameters#Parameters":" RowType (FromDelimited) "},"title":"DelimReader"},"/ExtraMojo/extramojo/io/delimited/DelimWriter/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = False ","delimwriter#\u003ccode\u003eDelimWriter\u003c/code\u003e":"Mojo struct ü°≠\nDelimWriter @memory_only struct DelimWriter[W: Movable \u0026 Writer] Write delimited data.","fields#Fields":" delim (String): The delimiter to use. writer (BufferedWriter[W]): The BufferedWriter to write to. write_header (Bool): Whether or not to write headers. needs_to_write_header (Bool): Whether or not we need to write the headers still. ","implemented-traits#Implemented traits":"AnyType, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, var writer: BufferedWriter[W], *, var delim: String, write_header: Bool) Create a DelimWriter. Args:\nwriter (BufferedWriter): The BufferedWriter to write to. delim (String): The delimiter to use. write_header (Bool): Whether or not to write headers. self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, var existing: Self) Details Args:\nexisting (Self) self (Self) Returns:\nSelf\n__enter__ fn __enter__(var self) -\u003e Self Details Args:\nself (Self) Returns:\nSelf\nflush fn flush(mut self) Details Args:\nself (Self) close fn close(mut self) Details Args:\nself (Self) Raises:\nwrite_record fn write_record[*Ts: Writable](mut self, *args: *Ts) Write the passed in arguments as a delimited record. Parameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts) Raises:\nwrite_field fn write_field[T: Writable](mut self, column: T, *, is_last: Bool) Write a single field, delimited by the configured delimiter. Parameters:\nT (Writable) Args:\nself (Self) column (T) is_last (Bool) Raises:\nserialize fn serialize[T: ToDelimited](mut self, value: T) Write a struct that implements ToDelimted to the underlying writer. Parameters:\nT (ToDelimited) Args:\nself (Self) value (T) Raises:","parameters#Parameters":" W (Movable \u0026 Writer) "},"title":"DelimWriter"},"/ExtraMojo/extramojo/io/delimited/FromDelimited/":{"data":{"aliases#Aliases":" __del__is_trivial = : A flag (often compiler generated) to indicate whether the implementation of __del__ is trivial. The implementation of __del__ is considered to be trivial if: The struct has a compiler-generated trivial destructor and all its fields have a trivial __del__ method. In practice, it means that the __del__ can be considered as no-op.\n__copyinit__is_trivial = : A flag (often compiler generated) to indicate whether the implementation of __copyinit__ is trivial. The implementation of __copyinit__ is considered to be trivial if: The struct has a compiler-generated trivial __copyinit__ and all its fields have a trivial __copyinit__ method. In practice, it means the value can be copied by copying the bits from one location to another without side effects.\n__moveinit__is_trivial = : A flag (often compiler generated) to indicate whether the implementation of __moveinit__ is trivial. The implementation of __moveinit__ is considered to be trivial if: The struct has a compiler-generated __moveinit__ and all its fields have a trivial __moveinit__ method. In practice, it means the value can be moved by moving the bits from one location to another without side effects.","fromdelimited#\u003ccode\u003eFromDelimited\u003c/code\u003e":"Mojo trait ü°≠\nFromDelimitedCreate an instance of Self from the iterator over Span[UInt8] bytes.","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __copyinit__ @staticmethod fn __copyinit__(out self: _Self, existing: _Self, /) Create a new instance of the value by copying an existing one. Args:\nexisting (_Self): The value to copy. self (_Self) Returns:\n_Self\n__moveinit__ @staticmethod fn __moveinit__(out self: _Self, var existing: _Self, /) Create a new instance of the value by moving the value of another. Args:\nexisting (_Self): The value to move. self (_Self) Returns:\n_Self\nfrom_delimited @staticmethod fn from_delimited(mut data: SplitIterator[origin], header_values: Optional[List[String]] = None) -\u003e _Self Details Args:\ndata (SplitIterator) header_values (Optional) Returns:\n_Self\nRaises:\ncopy fn copy(self: _Self) -\u003e _Self Explicitly construct a copy of self. Args:\nself (_Self) Returns:\n_Self: A copy of this value."},"title":"FromDelimited"},"/ExtraMojo/extramojo/io/delimited/ToDelimited/":{"data":{"aliases#Aliases":" __del__is_trivial = : A flag (often compiler generated) to indicate whether the implementation of __del__ is trivial. The implementation of __del__ is considered to be trivial if: The struct has a compiler-generated trivial destructor and all its fields have a trivial __del__ method. In practice, it means that the __del__ can be considered as no-op.","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ write_to_delimited fn write_to_delimited(self: _Self, mut writer: DelimWriter[W]) Write self to the passed in writer. This should probably be done with DelimWriter.write_record or a series of DelimWriter.write_field calls.\nArgs:\nself (_Self) writer (DelimWriter) Raises:\nwrite_header fn write_header(self: _Self, mut writer: DelimWriter[W]) Write selfs headers to the passed in writer. This should probably be done with DelimWriter.write_record or a series of DelimWriter.write_field calls.\nArgs:\nself (_Self) writer (DelimWriter) Raises:","todelimited#\u003ccode\u003eToDelimited\u003c/code\u003e":"Mojo trait ü°≠\nToDelimited"},"title":"ToDelimited"},"/ExtraMojo/extramojo/math/":{"data":{"math#\u003ccode\u003emath\u003c/code\u003e":"Mojo package ü°≠\nmath","modules#Modules":" ops "},"title":"math"},"/ExtraMojo/extramojo/math/ops/":{"data":{"functions#Functions":" saturating_sub saturating_add ","ops#\u003ccode\u003eops\u003c/code\u003e":"Mojo module ü°≠\nops"},"title":"ops"},"/ExtraMojo/extramojo/math/ops/saturating_add/":{"data":{"saturating_add#\u003ccode\u003esaturating_add\u003c/code\u003e":"Mojo function ü°≠\nsaturating_add ‚ûï¬† ‚ûñ fn saturating_add[data: DType, width: Int](lhs: SIMD[data, width], rhs: SIMD[data, width]) -\u003e SIMD[data, width] Saturating SIMD addition. https://llvm.org/docs/LangRef.html#llvm-uadd-sat-intrinsics https://llvm.org/docs/LangRef.html#llvm-sadd-sat-intrinsics\nParameters:\ndata (DType) width (Int) Args:\nlhs (SIMD) rhs (SIMD) Returns:\nSIMD"},"title":"saturating_add"},"/ExtraMojo/extramojo/math/ops/saturating_sub/":{"data":{"saturating_sub#\u003ccode\u003esaturating_sub\u003c/code\u003e":"Mojo function ü°≠\nsaturating_sub ‚ûï¬† ‚ûñ fn saturating_sub[data: DType, width: Int](lhs: SIMD[data, width], rhs: SIMD[data, width]) -\u003e SIMD[data, width] Saturating SIMD subtraction. https://llvm.org/docs/LangRef.html#llvm-usub-sat-intrinsics https://llvm.org/docs/LangRef.html#llvm-ssub-sat-intrinsics\nParameters:\ndata (DType) width (Int) Args:\nlhs (SIMD) rhs (SIMD) Returns:\nSIMD"},"title":"saturating_sub"},"/ExtraMojo/extramojo/stats/":{"data":{"modules#Modules":" sampling: Reservoir sampling on a stream. ","stats#\u003ccode\u003estats\u003c/code\u003e":"Mojo package ü°≠\nstatsBasic stats."},"title":"stats"},"/ExtraMojo/extramojo/stats/sampling/":{"data":{"references#References":" Algorithm R: https://en.wikipedia.org/wiki/Reservoir_sampling ","sampling#\u003ccode\u003esampling\u003c/code\u003e":"Mojo module ü°≠\nsamplingReservoir sampling on a stream.","structs#Structs":" ReservoirSampler: Sample N items from a stream of unknown length. "},"title":"sampling"},"/ExtraMojo/extramojo/stats/sampling/ReservoirSampler/":{"data":{"aliases#Aliases":" __del__is_trivial = False __moveinit__is_trivial = True __copyinit__is_trivial = False ","fields#Fields":" reservoir (List[T]) values_to_collect (Int) seen_values (Int) ","implemented-traits#Implemented traits":"AnyType, Copyable, Movable, UnknownDestructibility","methods#Methods":" ‚ûï¬† ‚ûñ __init__ fn __init__(out self, values_to_collect: Int) Details Args:\nvalues_to_collect (Int) self (Self) Returns:\nSelf\ninsert fn insert(mut self, item: T) Add an element. The element will be tested for addition to the reservoir.\nArgs:\nself (Self) item (T) ","parameters#Parameters":" T (Copyable \u0026 Movable) ","reservoirsampler#\u003ccode\u003eReservoirSampler\u003c/code\u003e":"Mojo struct ü°≠\nReservoirSampler @memory_only struct ReservoirSampler[T: Copyable \u0026 Movable] Sample N items from a stream of unknown length.\nSample all the elements, this should retain the order since we always automatically take the first N elements.\nfrom random import seed from testing import assert_equal from extramojo.stats.sampling import ReservoirSampler # Set the global random seed seed(42) var sampler = ReservoirSampler[Int](10) var items = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) for item in items: sampler.insert(item) assert_equal(sampler.reservoir, items) Sample only a subset of the input list.\nvar sampler = ReservoirSampler[Int](5) for item in items: sampler.insert(item) assert_equal(len(sampler.reservoir), 5) assert_equal(sampler.reservoir, List(0, 9, 2, 3, 7)) Sample only a single element.\nvar sampler = ReservoirSampler[Int](1) for item in items: sampler.insert(item) assert_equal(len(sampler.reservoir), 1) assert_equal(sampler.reservoir, List(6)) Sample more elements than are in the input stream.\nvar sampler = ReservoirSampler[Int](11) for item in items: sampler.insert(item) assert_equal(len(sampler.reservoir), 10) assert_equal(sampler.reservoir, items) Sample zero elements\nvar sampler = ReservoirSampler[Int](0) for item in items: sampler.insert(item) assert_equal(len(sampler.reservoir), 0) assert_equal(sampler.reservoir, List[Int]()) "},"title":"ReservoirSampler"}}