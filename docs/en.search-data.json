{"/ExtraMojo.git/ExtraMojo/":{"data":{"extramojo#\u003ccode\u003eExtraMojo\u003c/code\u003e":"Mojo package 🡭\nExtraMojo","packages#Packages":" bstr cli io regex stats "},"title":"ExtraMojo"},"/ExtraMojo.git/ExtraMojo/bstr/":{"data":{"bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo package 🡭\nbstr","modules#Modules":" bstr memchr "},"title":"bstr"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) CAPITAL_A = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"A\"))) CAPITAL_Z = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"Z\"))) LOWER_A = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"a\"))) LOWER_Z = SIMD(ord[::Bool,::Origin[$0]](StringSlice(\"z\"))) ASCII_CASE_MASK = SIMD(32) ZERO = SIMD(0) ","bstr#\u003ccode\u003ebstr\u003c/code\u003e":"Mojo module 🡭\nbstr","functions#Functions":" find_chr_all_occurrences is_ascii_uppercase is_ascii_lowercase to_ascii_lowercase to_ascii_uppercase find ","structs#Structs":" SplitIterator "},"title":"bstr"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/SplitIterator/":{"data":{"fields#Fields":" inner (Span[SIMD[uint8, 1], origin]) split_on (SIMD[uint8, 1]) current (Int) len (Int) next_split (Optional[_StartEnd]) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, to_split: Span[SIMD[uint8, 1], origin], split_on: SIMD[uint8, 1]) Args:\nto_split (Span[SIMD[uint8, 1], origin]) split_on (SIMD[uint8, 1]) self (Self) Returns:\nSelf\n__iter__ fn __iter__(self) -\u003e Self Args:\nself (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e Span[SIMD[uint8, 1], origin] Args:\nself (Self) Returns:\nSpan[SIMD[uint8, 1], origin]\npeek fn peek(self) -\u003e Optional[Span[SIMD[uint8, 1], origin]] Args:\nself (Self) Returns:\nOptional[Span[SIMD[uint8, 1], origin]]","parameters#Parameters":" is_mutable (Bool) origin (Origin[is_mutable]) ","splititerator#\u003ccode\u003eSplitIterator\u003c/code\u003e":"Mojo struct 🡭\nSplitIterator @memory_only struct SplitIterator[is_mutable: Bool, //, origin: Origin[is_mutable]] "},"title":"SplitIterator"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/find/":{"data":{"find#\u003ccode\u003efind\u003c/code\u003e":"Mojo function 🡭\nfind fn find(haystack: Span[SIMD[uint8, 1], origin], needle: Span[SIMD[uint8, 1], origin]) -\u003e Optional[Int] Look for the substring needle in the haystack.\nThis returns the index of the start of the first occurrence of needle.\nArgs:\nhaystack (Span[SIMD[uint8, 1], origin]) needle (Span[SIMD[uint8, 1], origin]) Returns:\nOptional[Int]"},"title":"find"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/find_chr_all_occurrences/":{"data":{"find_chr_all_occurrences#\u003ccode\u003efind_chr_all_occurrences\u003c/code\u003e":"Mojo function 🡭\nfind_chr_all_occurrences fn find_chr_all_occurrences(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1]) -\u003e List[Int] Find all the occurrences of chr in the input buffer.\nArgs:\nhaystack (Span[SIMD[uint8, 1], origin]) chr (SIMD[uint8, 1]) Returns:\nList[Int]"},"title":"find_chr_all_occurrences"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/is_ascii_lowercase/":{"data":{"is_ascii_lowercase#\u003ccode\u003eis_ascii_lowercase\u003c/code\u003e":"Mojo function 🡭\nis_ascii_lowercase fn is_ascii_lowercase(value: SIMD[uint8, 1]) -\u003e Bool Args:\nvalue (SIMD[uint8, 1]) Returns:\nBool"},"title":"is_ascii_lowercase"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/is_ascii_uppercase/":{"data":{"is_ascii_uppercase#\u003ccode\u003eis_ascii_uppercase\u003c/code\u003e":"Mojo function 🡭\nis_ascii_uppercase fn is_ascii_uppercase(value: SIMD[uint8, 1]) -\u003e Bool Args:\nvalue (SIMD[uint8, 1]) Returns:\nBool"},"title":"is_ascii_uppercase"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/to_ascii_lowercase/":{"data":{"to_ascii_lowercase#\u003ccode\u003eto_ascii_lowercase\u003c/code\u003e":"Mojo function 🡭\nto_ascii_lowercase fn to_ascii_lowercase(mut buffer: List[SIMD[uint8, 1], hint_trivial_type]) Lowercase all ascii a-zA-Z characters.\nArgs:\nbuffer (List[SIMD[uint8, 1], hint_trivial_type]) "},"title":"to_ascii_lowercase"},"/ExtraMojo.git/ExtraMojo/bstr/bstr/to_ascii_uppercase/":{"data":{"to_ascii_uppercase#\u003ccode\u003eto_ascii_uppercase\u003c/code\u003e":"Mojo function 🡭\nto_ascii_uppercase fn to_ascii_uppercase(mut buffer: List[SIMD[uint8, 1], hint_trivial_type]) Uppercase all ascii a-zA-Z characters.\nArgs:\nbuffer (List[SIMD[uint8, 1], hint_trivial_type]) "},"title":"to_ascii_uppercase"},"/ExtraMojo.git/ExtraMojo/bstr/memchr/":{"data":{"aliases#Aliases":" SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) LOOP_SIZE = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()).__mul__(4) ","functions#Functions":" memchr memchr_wide ","memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo module 🡭\nmemchr"},"title":"memchr"},"/ExtraMojo.git/ExtraMojo/bstr/memchr/memchr/":{"data":{"memchr#\u003ccode\u003ememchr\u003c/code\u003e":"Mojo function 🡭\nmemchr fn memchr(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1], start: Int = 0) -\u003e Int Function to find the next occurrence of character.\nArgs:\nhaystack (Span[SIMD[uint8, 1], origin]) chr (SIMD[uint8, 1]) start (Int) Returns:\nInt"},"title":"memchr"},"/ExtraMojo.git/ExtraMojo/bstr/memchr/memchr_wide/":{"data":{"memchr_wide#\u003ccode\u003ememchr_wide\u003c/code\u003e":"Mojo function 🡭\nmemchr_wide fn memchr_wide(haystack: Span[SIMD[uint8, 1], origin], chr: SIMD[uint8, 1], start: Int = 0) -\u003e Int Function to find the next occurrence of character.\nArgs:\nhaystack (Span[SIMD[uint8, 1], origin]) chr (SIMD[uint8, 1]) start (Int) Returns:\nInt"},"title":"memchr_wide"},"/ExtraMojo.git/ExtraMojo/cli/":{"data":{"cli#\u003ccode\u003ecli\u003c/code\u003e":"Mojo package 🡭\ncli","modules#Modules":" parser: A very basic CLI Opt Parser. "},"title":"cli"},"/ExtraMojo.git/ExtraMojo/cli/parser/":{"data":{"parser#\u003ccode\u003eparser\u003c/code\u003e":"Mojo module 🡭\nparserA very basic CLI Opt Parser.\nfrom testing import assert_equal, assert_true from ExtraMojo.cli.parser import OptParser, OptConfig, OptKind var args = List(String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\")) var program_name = \"example\" var parser = OptParser(name=\"example\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) # Note, a user would call parser.parse_sys_args() var opts = parser.parse_args(args) assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) ","structs#Structs":" OptKind: The viable types for an option to have. OptValue: When an option is parsed, it’s stored as an OptValue. OptConfig: Create an option to be added to the [OptParser]. ParsedOpts: The parsed CLI options. Access your values with [ParsedOpts.get_string()], [ParsedOpts.get_int()], etc. OptParser: [OptParser] will try to parse your long-form CLI options. Subcommand: A subcommand. SubcommandParser: Subcommands are created by passing in the command, and an [OptParser]. "},"title":"parser"},"/ExtraMojo.git/ExtraMojo/cli/parser/OptConfig/":{"data":{"fields#Fields":" long_name (String): Required long name of, this will be used as the cli value as --long_name. default_value (Optional[String]): If there is one, the Stringified deafult value. This will be parsed via [OptKind]. value_kind (OptKind): The type of the value for this option. is_flag (Bool): If it’s a flag, then it’s value_kind needs to be Bool. description (String): Long for description, for best results, don’t add a newline. ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned long_name: String, value_kind: OptKind, *, is_flag: Bool = False, owned description: String = String(\"\"), owned default_value: Optional[String] = Optional(None)) Args:\nlong_name (String) value_kind (OptKind) is_flag (Bool) description (String) default_value (Optional[String]) self (Self) Returns:\nSelf\nRaises:","optconfig#\u003ccode\u003eOptConfig\u003c/code\u003e":"Mojo struct 🡭\nOptConfig @memory_only struct OptConfig Create an option to be added to the [OptParser]."},"title":"OptConfig"},"/ExtraMojo.git/ExtraMojo/cli/parser/OptKind/":{"data":{"aliases#Aliases":" StringLike = OptKind(SIMD(0)) IntLike = OptKind(SIMD(1)) FloatLike = OptKind(SIMD(2)) BoolLike = OptKind(SIMD(3)) ","fields#Fields":" value (SIMD[uint8, 1]) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, Stringable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, value: SIMD[uint8, 1]) Args:\nvalue (SIMD[uint8, 1]) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Args:\nself (Self) other (Self) Returns:\nBool\n__str__ fn __str__(self) -\u003e String Args:\nself (Self) Returns:\nString","optkind#\u003ccode\u003eOptKind\u003c/code\u003e":"Mojo struct 🡭\nOptKind @memory_only struct OptKind The viable types for an option to have."},"title":"OptKind"},"/ExtraMojo.git/ExtraMojo/cli/parser/OptParser/":{"data":{"fields#Fields":" options (Dict[String, OptConfig]): The options this will attempt to parse. program_description (String): The description of the program, to be used in the help message. program_name (String): Your programs name, to be used in the help message. ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, *, name: String, description: String = String(\"\")) Args:\nname (String) description (String) self (Self) Returns:\nSelf\nRaises:\nadd_opt fn add_opt(mut self, owned arg: OptConfig) Add an [OptConfig].\nArgs:\nself (Self) arg (OptConfig) help_msg fn help_msg(self) -\u003e String Get the help message string based on the currently added options.\nArgs:\nself (Self) Returns:\nString\nparse_sys_args fn parse_sys_args(mut self) -\u003e ParsedOpts Parse the arguments from sys.argv().\nArgs:\nself (Self) Returns:\nParsedOpts\nRaises:\nparse_args fn parse_args(self, args: List[String]) -\u003e ParsedOpts Parse the arguments passed in via args.\nArgs:\nself (Self) args (List[String]) Returns:\nParsedOpts\nRaises:","optparser#\u003ccode\u003eOptParser\u003c/code\u003e":"Mojo struct 🡭\nOptParser @memory_only struct OptParser [OptParser] will try to parse your long-form CLI options."},"title":"OptParser"},"/ExtraMojo.git/ExtraMojo/cli/parser/OptValue/":{"data":{"fields#Fields":" kind (OptKind) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, str_value: String = String(\"\")) Args:\nstr_value (String) self (Self) Returns:\nSelf\nfn __init__(out self, int_value: Int = 0) Args:\nint_value (Int) self (Self) Returns:\nSelf\nfn __init__(out self, float_value: SIMD[float64, 1] = SIMD(#kgen.float_literal\u003c0|1\u003e)) Args:\nfloat_value (SIMD[float64, 1]) self (Self) Returns:\nSelf\nfn __init__(out self, bool_value: Bool = False) Args:\nbool_value (Bool) self (Self) Returns:\nSelf\nget_string fn get_string(self) -\u003e Optional[String] Args:\nself (Self) Returns:\nOptional[String]\nget_int fn get_int(self) -\u003e Optional[Int] Args:\nself (Self) Returns:\nOptional[Int]\nget_float fn get_float(self) -\u003e Optional[SIMD[float64, 1]] Args:\nself (Self) Returns:\nOptional[SIMD[float64, 1]]\nget_bool fn get_bool(self) -\u003e Optional[Bool] Args:\nself (Self) Returns:\nOptional[Bool]\nparse_string @staticmethod fn parse_string(value: String) -\u003e Self Args:\nvalue (String) Returns:\nSelf\nparse_int @staticmethod fn parse_int(value: String) -\u003e Self Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_float @staticmethod fn parse_float(value: String) -\u003e Self Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_bool @staticmethod fn parse_bool(value: String) -\u003e Self Args:\nvalue (String) Returns:\nSelf\nRaises:\nparse_kind @staticmethod fn parse_kind(kind: OptKind, value: String) -\u003e Self Parse the string based on the value of [OptKind].\nArgs:\nkind (OptKind) value (String) Returns:\nSelf\nRaises:","optvalue#\u003ccode\u003eOptValue\u003c/code\u003e":"Mojo struct 🡭\nOptValue @memory_only struct OptValue When an option is parsed, it’s stored as an OptValue.\nTo get concrete values out of the [ParsedOpts] prefer to use the ParsedOpts.get_\u003ctype\u003e() methods."},"title":"OptValue"},"/ExtraMojo.git/ExtraMojo/cli/parser/ParsedOpts/":{"data":{"fields#Fields":" options (Dict[String, OptValue]) args (List[String]) help_msg (String) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned help_msg: String = String(\"\")) Args:\nhelp_msg (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(ref self) -\u003e Pointer[String, self_is_origin.help_msg] Get a nicely formatted help string.\nArgs:\nself (Self) Returns:\nPointer[String, self_is_origin.help_msg]\nget_string fn get_string(self, key: String) -\u003e String Try to get the option specified with the given key as a String.\nThis will raise if the key is not found, or if the type of the option doesn’t match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nString\nRaises:\nget_int fn get_int(self, key: String) -\u003e Int Try to get the option specified with the given key as an Int.\nThis will raise if the key is not found, or if the type of the option doesn’t match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nInt\nRaises:\nget_float fn get_float(self, key: String) -\u003e SIMD[float64, 1] Try to get the option specified with the given key as a Float64.\nThis will raise if the key is not found, or if the type of the option doesn’t match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nSIMD[float64, 1]\nRaises:\nget_bool fn get_bool(self, key: String) -\u003e Bool Try to get the option specified with the given key as a Bool.\nThis will raise if the key is not found, or if the type of the option doesn’t match asked-for type.\nArgs:\nself (Self) key (String) Returns:\nBool\nRaises:","parsedopts#\u003ccode\u003eParsedOpts\u003c/code\u003e":"Mojo struct 🡭\nParsedOpts @memory_only struct ParsedOpts The parsed CLI options. Access your values with [ParsedOpts.get_string()], [ParsedOpts.get_int()], etc.\nAccess CLI arguments from [ParsedOpts.args]. Get the help message with [ParsedOpts.get_help_message].\nNote that there is an automatic help flag added to your options, it can be overridden by another option with that same name. The input args are first scanned for “–help” and if that is found the parser will exit early, returning the parsed value of the “–help” flag (or option if you have overridden it). It is up to the user to check for the “help” option being set and print the help message."},"title":"ParsedOpts"},"/ExtraMojo.git/ExtraMojo/cli/parser/Subcommand/":{"data":{"fields#Fields":" parser (OptParser) ","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, ExplicitlyCopyable, Hashable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned name: String, owned parser: OptParser) Args:\nname (String) parser (OptParser) self (Self) Returns:\nSelf\n__eq__ fn __eq__(self, other: Self) -\u003e Bool Args:\nself (Self) other (Self) Returns:\nBool\n__ne__ fn __ne__(self, other: Self) -\u003e Bool Args:\nself (Self) other (Self) Returns:\nBool\n__hash__ fn __hash__(self) -\u003e UInt Args:\nself (Self) Returns:\nUInt","subcommand#\u003ccode\u003eSubcommand\u003c/code\u003e":"Mojo struct 🡭\nSubcommand @memory_only struct Subcommand A subcommand.\nThe name of the subcommand is the OptParser.name. The name of the subcommand will be checked against the first value in the input args. The help message will display the program description for the OptParser that is associated with this subcommand."},"title":"Subcommand"},"/ExtraMojo.git/ExtraMojo/cli/parser/SubcommandParser/":{"data":{"fields#Fields":" commands (Dict[String, Subcommand]) description (String) name (String) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, *, owned name: String, owned description: String = String(\"\")) Args:\nname (String) description (String) self (Self) Returns:\nSelf\nget_help_message fn get_help_message(self) -\u003e String Create the help message for the subcommands.\nArgs:\nself (Self) Returns:\nString\nRaises:\nadd_command fn add_command(mut self, command: Subcommand) Add a subcommand.\nArgs:\nself (Self) command (Subcommand) parse_args fn parse_args(self, args: List[String]) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the input args, expecting a subcommand.\nArgs:\nself (Self) args (List[String]) Returns:\nOptional[Tuple[String, ParsedOpts]]\nRaises:\nparse_sys_args fn parse_sys_args(self) -\u003e Optional[Tuple[String, ParsedOpts]] Parse the sys.argv() list.\nArgs:\nself (Self) Returns:\nOptional[Tuple[String, ParsedOpts]]\nRaises:","subcommandparser#\u003ccode\u003eSubcommandParser\u003c/code\u003e":"Mojo struct 🡭\nSubcommandParser @memory_only struct SubcommandParser Subcommands are created by passing in the command, and an [OptParser].\nThe parser is for the options for the subcommand.\nfrom testing import assert_equal, assert_true from ExtraMojo.cli.parser import OptParser, OptConfig, OptKind, SubcommandParser, Subcommand var args = List(String(\"do-work\"), String(\"--file\"), String(\"/path/to/thing\"), String(\"--count\"), String(\"42\"), String(\"--fraction\"), String(\"-0.2\"), String(\"--verbose\")) var program_name = \"example\" var parser = OptParser(name=\"do-work\", description=\"An example program.\") parser.add_opt(OptConfig(\"file\", OptKind.StringLike, default_value=None, description=\"A file with something in it.\")) parser.add_opt(OptConfig(\"count\", OptKind.IntLike, default_value=String(\"100\"), description=\"A number.\")) parser.add_opt(OptConfig(\"fraction\", OptKind.FloatLike, default_value=String(\"0.5\"), description=\"Some interesting fraction to keep.\")) # Note that with flags, the OptKind must be BoolLike and there must be a default_value specified. parser.add_opt(OptConfig(\"verbose\", OptKind.BoolLike, is_flag=True, default_value=String(\"False\"), description=\"Turn up the logging.\")) var cmd = Subcommand(parser) # uses the name from the passed in parser var cmd_parser = SubcommandParser(name=String(\"cool-program\"), description=\"Do some cool stuff.\") cmd_parser.add_command(cmd) # Note, a user would call parser.parse_sys_args() var cmd_and_opts = cmd_parser.parse_args(args) if not cmd_and_opts: print(cmd_parser.get_help_message()) parsed_cmd, opts = cmd_and_opts.value() if parsed_cmd == cmd.parser.program_name: assert_equal(opts.get_string(\"file\"), String(\"/path/to/thing\")) assert_equal(opts.get_int(\"count\"), 42) assert_equal(opts.get_float(\"fraction\"), -0.2) assert_equal(opts.get_bool(\"verbose\"), True) assert_true(len(opts.get_help_message()[]) \u003e 0) "},"title":"SubcommandParser"},"/ExtraMojo.git/ExtraMojo/io/":{"data":{"io#\u003ccode\u003eio\u003c/code\u003e":"Mojo package 🡭\nio","modules#Modules":" buffered: Helper functions for working with files delimited "},"title":"io"},"/ExtraMojo.git/ExtraMojo/io/buffered/":{"data":{"aliases#Aliases":" NEW_LINE = 10 SIMD_U8_WIDTH = Int(simdwidthof[::DType,__mlir_type.!kgen.target]()) BUF_SIZE = 131072 ","buffered#\u003ccode\u003ebuffered\u003c/code\u003e":"Mojo module 🡭\nbufferedHelper functions for working with files","functions#Functions":" read_lines for_each_line get_next_line ","structs#Structs":" BufferedReader: BufferedReader for readying lines and bytes from a file in a buffered way. BufferedWriter "},"title":"buffered"},"/ExtraMojo.git/ExtraMojo/io/buffered/BufferedReader/":{"data":{"bufferedreader#\u003ccode\u003eBufferedReader\u003c/code\u003e":"Mojo struct 🡭\nBufferedReader @memory_only struct BufferedReader BufferedReader for readying lines and bytes from a file in a buffered way.","fields#Fields":" fh (FileHandle) buffer (UnsafePointer[SIMD[uint8, 1]]) file_offset (Int) buffer_offset (Int) buffer_capacity (Int) buffer_len (Int) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned fh: FileHandle, buffer_capacity: Int = 131072) Args:\nfh (FileHandle) buffer_capacity (Int) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(owned self) Args:\nself (Self) __enter__ fn __enter__(owned self) -\u003e Self Args:\nself (Self) Returns:\nSelf\nread_bytes fn read_bytes(mut self, mut buffer: List[SIMD[uint8, 1]]) -\u003e Int Read up to len(buffer) bytes. This returns the number of bytes read. If the number of bytes read is less then len(buffer) then EOF has been reached.\nArgs:\nself (Self) buffer (List[SIMD[uint8, 1]]) Returns:\nInt\nRaises:\nread_until fn read_until(mut self, mut line_buffer: List[SIMD[uint8, 1]], char: UInt = 10) -\u003e Int Fill the given line_buffer until the given char is hit, or EOF.\nReturns the number of bytes read.\nArgs:\nself (Self) line_buffer (List[SIMD[uint8, 1]]) char (UInt) Returns:\nInt\nRaises:"},"title":"BufferedReader"},"/ExtraMojo.git/ExtraMojo/io/buffered/BufferedWriter/":{"data":{"bufferedwriter#\u003ccode\u003eBufferedWriter\u003c/code\u003e":"Mojo struct 🡭\nBufferedWriter @memory_only struct BufferedWriter ","fields#Fields":" fh (FileHandle) buffer (List[SIMD[uint8, 1]]) buffer_capacity (Int) buffer_len (Int) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility, Writer","methods#Methods":"__init__ fn __init__(out self, owned fh: FileHandle, buffer_capacity: Int = 131072) Args:\nfh (FileHandle) buffer_capacity (Int) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Args:\nexisting (Self) self (Self) Returns:\nSelf\n__del__ fn __del__(owned self) Args:\nself (Self) __enter__ fn __enter__(owned self) -\u003e Self Args:\nself (Self) Returns:\nSelf\nclose fn close(mut self) Args:\nself (Self) Raises:\nwrite_bytes fn write_bytes(mut self, bytes: Span[SIMD[uint8, 1], origin]) Args:\nself (Self) bytes (Span[SIMD[uint8, 1], origin]) write fn write[*Ts: Writable](mut self, *args: *Ts) Parameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts) flush fn flush(mut self) Args:\nself (Self) "},"title":"BufferedWriter"},"/ExtraMojo.git/ExtraMojo/io/buffered/for_each_line/":{"data":{"for_each_line#\u003ccode\u003efor_each_line\u003c/code\u003e":"Mojo function 🡭\nfor_each_line fn for_each_line[func: fn[Bool, Origin[$0]](Span[SIMD[uint8, 1], $1], Int, Int) capturing -\u003e None](path: String, buf_size: Int = 131072) Call the provided callback on each line.\nThe callback will be given a buffer, and the [start, end) of where the line is in that buffer.\nParameters:\nfunc (fn[Bool, Origin[$0]](Span[SIMD[uint8, 1], $1], Int, Int) capturing -\u003e None) Args:\npath (String) buf_size (Int) Raises:"},"title":"for_each_line"},"/ExtraMojo.git/ExtraMojo/io/buffered/get_next_line/":{"data":{"get_next_line#\u003ccode\u003eget_next_line\u003c/code\u003e":"Mojo function 🡭\nget_next_line fn get_next_line[is_mutable: Bool, //, origin: Origin[$0]](buffer: Span[SIMD[uint8, 1], origin], start: Int) -\u003e Span[SIMD[uint8, 1], origin] Function to get the next line using either SIMD instruction (default) or iteratively.\nParameters:\nis_mutable (Bool) origin (Origin[$0]) Args:\nbuffer (Span[SIMD[uint8, 1], origin]) start (Int) Returns:\nSpan[SIMD[uint8, 1], origin]"},"title":"get_next_line"},"/ExtraMojo.git/ExtraMojo/io/buffered/read_lines/":{"data":{"read_lines#\u003ccode\u003eread_lines\u003c/code\u003e":"Mojo function 🡭\nread_lines fn read_lines(path: String, buf_size: Int = 131072) -\u003e List[List[SIMD[uint8, 1]]] Read all the lines in the file and return them as a [DynamicVector] of [Tensor[DType.int8]].\nArgs:\npath (String) buf_size (Int) Returns:\nList[List[SIMD[uint8, 1]]]\nRaises:"},"title":"read_lines"},"/ExtraMojo.git/ExtraMojo/io/delimited/":{"data":{"delimited#\u003ccode\u003edelimited\u003c/code\u003e":"Mojo module 🡭\ndelimited","structs#Structs":" DelimReader: Read delimited data that is delimited by a single bytes. DelimWriter: Write delimited data. ","traits#Traits":" FromDelimited: Create an inststance of [Self] from the iterator over [Span[UInt8]] bytes. ToDelimited "},"title":"delimited"},"/ExtraMojo.git/ExtraMojo/io/delimited/DelimReader/":{"data":{"delimreader#\u003ccode\u003eDelimReader\u003c/code\u003e":"Mojo struct 🡭\nDelimReader @memory_only struct DelimReader[RowType: FromDelimited] Read delimited data that is delimited by a single bytes.\nThe [RowType] must implement [FromBytes] which is passed an iterator over the split up line.","fields#Fields":" delim (SIMD[uint8, 1]) reader (BufferedReader) next_elem (Optional[RowType]) buffer (List[SIMD[uint8, 1]]) len (Int) has_header (Bool) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned reader: BufferedReader, *, delim: SIMD[uint8, 1], has_header: Bool) Args:\nreader (BufferedReader) delim (SIMD[uint8, 1]) has_header (Bool) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Args:\nexisting (Self) self (Self) Returns:\nSelf\n__len__ fn __len__(self) -\u003e Int Args:\nself (Self) Returns:\nInt\n__has_next__ fn __has_next__(self) -\u003e Bool Args:\nself (Self) Returns:\nBool\n__next__ fn __next__(mut self) -\u003e RowType Args:\nself (Self) Returns:\nRowType\nRaises:\n__iter__ fn __iter__(owned self) -\u003e Self Args:\nself (Self) Returns:\nSelf","parameters#Parameters":" RowType (FromDelimited) "},"title":"DelimReader"},"/ExtraMojo.git/ExtraMojo/io/delimited/DelimWriter/":{"data":{"delimwriter#\u003ccode\u003eDelimWriter\u003c/code\u003e":"Mojo struct 🡭\nDelimWriter @memory_only struct DelimWriter Write delimited data.","fields#Fields":" delim (String) writer (BufferedWriter) write_header (Bool) needs_to_write_header (Bool) ","implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, owned writer: BufferedWriter, *, owned delim: String, write_header: Bool) Args:\nwriter (BufferedWriter) delim (String) write_header (Bool) self (Self) Returns:\nSelf\nRaises:\n__moveinit__ @staticmethod fn __moveinit__(out self, owned existing: Self) Args:\nexisting (Self) self (Self) Returns:\nSelf\n__enter__ fn __enter__(owned self) -\u003e Self Args:\nself (Self) Returns:\nSelf\nflush fn flush(mut self) Args:\nself (Self) close fn close(mut self) Args:\nself (Self) Raises:\nwrite_record fn write_record[*Ts: Writable](mut self, *args: *Ts) Write the passed in arguments as a delimited record.\nParameters:\n*Ts (Writable) Args:\nself (Self) *args (*Ts) Raises:\nwrite_column fn write_column[T: Writable](mut self, column: T, *, is_last: Bool) Parameters:\nT (Writable) Args:\nself (Self) column (T) is_last (Bool) Raises:\nserialize fn serialize[T: ToDelimited](mut self, value: T) Parameters:\nT (ToDelimited) Args:\nself (Self) value (T) Raises:"},"title":"DelimWriter"},"/ExtraMojo.git/ExtraMojo/io/delimited/FromDelimited/":{"data":{"fromdelimited#\u003ccode\u003eFromDelimited\u003c/code\u003e":"Mojo trait 🡭\nFromDelimitedCreate an inststance of [Self] from the iterator over [Span[UInt8]] bytes.","implemented-traits#Implemented traits":"AnyType, CollectionElement, Copyable, Movable, UnknownDestructibility","methods#Methods":"__copyinit__ @staticmethod fn __copyinit__(out self: _Self, existing: _Self, /) Create a new instance of the value by copying an existing one.\nArgs:\nexisting (_Self): The value to copy. self (_Self) Returns:\n_Self\n__moveinit__ @staticmethod fn __moveinit__(out self: _Self, owned existing: _Self, /) Create a new instance of the value by moving the value of another.\nArgs:\nexisting (_Self): The value to move. self (_Self) Returns:\n_Self\nfrom_delimited @staticmethod fn from_delimited(mut data: SplitIterator[origin]) -\u003e _Self Args:\ndata (SplitIterator[origin]) Returns:\n_Self\nRaises:"},"title":"FromDelimited"},"/ExtraMojo.git/ExtraMojo/io/delimited/ToDelimited/":{"data":{"implemented-traits#Implemented traits":"AnyType, UnknownDestructibility","methods#Methods":"write_to_delimited fn write_to_delimited(self: _Self, mut writer: DelimWriter) Args:\nself (_Self) writer (DelimWriter) Raises:\nwrite_header fn write_header(self: _Self, mut writer: DelimWriter) Args:\nself (_Self) writer (DelimWriter) Raises:","todelimited#\u003ccode\u003eToDelimited\u003c/code\u003e":"Mojo trait 🡭\nToDelimited"},"title":"ToDelimited"},"/ExtraMojo.git/ExtraMojo/regex/":{"data":{"modules#Modules":" simple_re: A very simple regex implemenation in Mojo inspired by Rob Pikes implementation. ","regex#\u003ccode\u003eregex\u003c/code\u003e":"Mojo package 🡭\nregex"},"title":"regex"},"/ExtraMojo.git/ExtraMojo/regex/simple_re/":{"data":{"aliases#Aliases":" START_ANCHOR = ord[::Bool,::Origin[$0]](StringSlice(\"^\")) END_ANCHOR = ord[::Bool,::Origin[$0]](StringSlice(\"$\")) DOT = ord[::Bool,::Origin[$0]](StringSlice(\".\")) STAR = ord[::Bool,::Origin[$0]](StringSlice(\"*\")) NULL = 0 ","functions#Functions":" is_match is_match_bytes is_match_here is_match_star ","simple_re#\u003ccode\u003esimple_re\u003c/code\u003e":"Mojo module 🡭\nsimple_reA very simple regex implemenation in Mojo inspired by Rob Pikes implementation.\nhttps://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html"},"title":"simple_re"},"/ExtraMojo.git/ExtraMojo/regex/simple_re/is_match/":{"data":{"is_match#\u003ccode\u003eis_match\u003c/code\u003e":"Mojo function 🡭\nis_match fn is_match(regexp: String, text: String) -\u003e Bool Search for regexp anywhere in text and return true if it matches.\nArgs:\nregexp (String) text (String) Returns:\nBool"},"title":"is_match"},"/ExtraMojo.git/ExtraMojo/regex/simple_re/is_match_bytes/":{"data":{"is_match_bytes#\u003ccode\u003eis_match_bytes\u003c/code\u003e":"Mojo function 🡭\nis_match_bytes fn is_match_bytes(regexp: Span[SIMD[uint8, 1], origin], text: Span[SIMD[uint8, 1], origin]) -\u003e Bool Args:\nregexp (Span[SIMD[uint8, 1], origin]) text (Span[SIMD[uint8, 1], origin]) Returns:\nBool"},"title":"is_match_bytes"},"/ExtraMojo.git/ExtraMojo/regex/simple_re/is_match_here/":{"data":{"is_match_here#\u003ccode\u003eis_match_here\u003c/code\u003e":"Mojo function 🡭\nis_match_here fn is_match_here(regexp: Span[SIMD[uint8, 1], origin], text: Span[SIMD[uint8, 1], origin]) -\u003e Bool Search for regexp at beginning of text.\nArgs:\nregexp (Span[SIMD[uint8, 1], origin]) text (Span[SIMD[uint8, 1], origin]) Returns:\nBool"},"title":"is_match_here"},"/ExtraMojo.git/ExtraMojo/regex/simple_re/is_match_star/":{"data":{"is_match_star#\u003ccode\u003eis_match_star\u003c/code\u003e":"Mojo function 🡭\nis_match_star fn is_match_star(c: SIMD[uint8, 1], regexp: Span[SIMD[uint8, 1], origin], text: Span[SIMD[uint8, 1], origin]) -\u003e Bool Search for c*regexp at beginning of text.\nArgs:\nc (SIMD[uint8, 1]) regexp (Span[SIMD[uint8, 1], origin]) text (Span[SIMD[uint8, 1], origin]) Returns:\nBool"},"title":"is_match_star"},"/ExtraMojo.git/ExtraMojo/stats/":{"data":{"modules#Modules":" sampling: Reservoir sampling on a stream. ","stats#\u003ccode\u003estats\u003c/code\u003e":"Mojo package 🡭\nstats"},"title":"stats"},"/ExtraMojo.git/ExtraMojo/stats/sampling/":{"data":{"references#References":" Algorithm R: https://en.wikipedia.org/wiki/Reservoir_sampling ","sampling#\u003ccode\u003esampling\u003c/code\u003e":"Mojo module 🡭\nsamplingReservoir sampling on a stream.","structs#Structs":" ReservoirSampler: Sample N items from a stream of unkown length. "},"title":"sampling"},"/ExtraMojo.git/ExtraMojo/stats/sampling/ReservoirSampler/":{"data":{"fields#Fields":" reservoir (List[T]) values_to_collect (Int) seen_values (Int) ","implemented-traits#Implemented traits":"AnyType, Copyable, ExplicitlyCopyable, Movable, UnknownDestructibility","methods#Methods":"__init__ fn __init__(out self, values_to_collect: Int) Args:\nvalues_to_collect (Int) self (Self) Returns:\nSelf\ninsert fn insert(mut self, item: T) Args:\nself (Self) item (T) ","parameters#Parameters":" T (CollectionElement) ","reservoirsampler#\u003ccode\u003eReservoirSampler\u003c/code\u003e":"Mojo struct 🡭\nReservoirSampler @memory_only struct ReservoirSampler[T: CollectionElement] Sample N items from a stream of unkown length.\nSample all the elements, this should retain the order since we always automatically take the first N elements.\nfrom random import seed from testing import assert_equal from ExtraMojo.stats.sampling import ReservoirSampler # Set the global random seed seed(42) var sampler = ReservoirSampler[Int](10) var items = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) for item in items: sampler.insert(item[]) assert_equal(sampler.reservoir, items) Sample only a subset of the input list.\nvar sampler = ReservoirSampler[Int](5) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 5) assert_equal(sampler.reservoir, List(0, 9, 2, 3, 7)) Sample only a single element.\nvar sampler = ReservoirSampler[Int](1) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 1) assert_equal(sampler.reservoir, List(6)) Sample more elements than are in the input stream.\nvar sampler = ReservoirSampler[Int](11) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 10) assert_equal(sampler.reservoir, items) Sample zero elements\nvar sampler = ReservoirSampler[Int](0) for item in items: sampler.insert(item[]) assert_equal(len(sampler.reservoir), 0) assert_equal(sampler.reservoir, List[Int]()) "},"title":"ReservoirSampler"}}